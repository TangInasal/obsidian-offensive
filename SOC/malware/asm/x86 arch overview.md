**CPU Architecture Overview**

![[Pasted image 20250712205243.png]]

**Overview:**
When a program has to be executed, it is loaded into the memory. 
From there, the Control Unit fetches one instruction at a time using the Instruction Pointer Register, and the Arithmetic Logic Unit executes it. 
The results are stored in either the Registers or the Memory.


**Registers Overview**

registers are divided into the following different types:
* [instruction pointer](#instruction-pointer)
- [General Purpose Registers](#General-Purpose-Registers)
- [Status Flag Registers](#Status-Flag-Registers)
- [Segment Registers](#Segment-Registers)
- [Memory Overview](#Memory-Overview)

# **Instruction-Pointer**
a register that contains the address of the next instruction to be executed by the CPU

32bit - EIP (Extended Intruction Pointer)
64bit - RIP (Register Intruction Pointer)

# **General-Purpose-Registers**
 are used during the general execution of instructions by the CPU.
 these registers are extended as 64-bit registers. **They contain the following registers**.
 * **EAX or RAX:** - Accumulator Register. Results of arithmetic operations are often stored in this register.
 * **EBX or RBX** - Base Register, often used to store the Base address for referencing an offset
 * **ECX or RCX** - Counter Register and is often used in counting operations such as loops, etc.
 * **EDX or RDX** -  Data Register, used in multiplication/division operations
 * **ESP or RSP** - Stack Pointer. It points to the top of the stack and is used in conjunction with the Stack Segment register. 
 * **EBP or RBP** -  Base Pointer. Used to access parameters passed by the stack. It is also used in conjunction with the Stack Segment register.
 * **ESI or RSI** - Source Index register. Used for string operations. It is used with the Data Segment (DS) register as an offset.
 * **EDI or RDI** - Destination Index register. It is also used for string operations. It is used with the Extra Segment (ES) register as an offset.
 * **R8-R15** - These 64-bit general-purpose registers are not present in 32-bit systems. They were introduced in the 64-bit systems.


# **Status-Flag-Registers**
* **Zero Flag:** - ZF indicates when the result of the last executed instruction was zero. For example, if an instruction is executed that subtracts a RAX from itself, the result will be 0. In this situation, the ZF will be set to 1.
* **Carry Flag** - CF indicates when the last executed instruction resulted in a number too big or too small for the destination. For example, if we add 0xFFFFFFFF and 0x00000001 and store the result in a 32-bit register, the result will be too big for the register. In this case, CF will be set to 1.
* **Sign Flag** - SF indicates if the result of an operation is negative or the most significant bit is set to 1. If these conditions are met, the SF is set to 1; otherwise, it is set to 0.
* **Trap Flag** - TF indicates if the processor is in debugging mode. When the TF is set, the CPU will execute one instruction at a time for debugging purposes. **This can be used by malware to identify if they are being run in a debugger.**
* 


# **Segment-Registers**

* **Code Segment** - CS register points to the Code section in the memory. 
* **Data Segment** -   DS register points to the program's data section in the memory.
* **Stack Segment** -  SS register points to the program's Stack in the memory.
* **Extra Segments**  **(ES, FS, and GS)** -  These extra segment registers point to different data sections. These and the DS register divide the program's memory into four distinct data sections.

# **Memory-Overview**
![[Pasted image 20250821115331.png]]


* **Code** - Contains the program's code. This section refers to the text section in a Portable Executable file, which includes instructions executed by the CPU. This section of the Memory has execute permissions,
* **Data** - Contains initialized data that is not variable and remains constant. It refers to the data section in a Portable Executable file. It often contains Global variables and other data that are not supposed to change during the program's execution.
* **Heap** - Also known as dynamic Memory, contains variables and data created and destroyed during program execution. When a variable is created, memory is allocated for that variable at runtime. And when that variable is deleted, the memory is freed. Hence the name dynamic memory.
* **Stack** - The Stack is one of the important parts of the Memory from a malware analysis point of view. This section of the Memory contains local variables, arguments passed on to the program, and the return address of the parent process that called the program. Since the return address is related to the control flow of the CPU's instructions, the stack is often targeted by malware to hijack the control flow.